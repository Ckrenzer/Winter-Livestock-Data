---
title: "Price Estimation"
author: "Connor Krenzer"
date: "4/20/2021"
output: html_document
---

# Exposition


I now plan on making this file a place to work with price prediction--mostly time series, but some other metrics would be interesting to explore too. Perhaps the estimates from time series could be compared to the estimates to linear models (and others!).




The other files were getting pretty long, and I want to have a separate location to examine different parts of the data. I am happy with the organization of `La Junta Collection.Rmd`, but `La Junta Modeling.Rmd` and `La Junta Predictions.Rmd` seem like black boxes.

In `La Junta Modeling.Rmd`, I just threw one model or graph after the other until I was happy throwing models at the data. The write-ups were nice, but they were mostly classification models. Classification models aren't all that helpful now that my scraping algorithm misses few values. Maybe that file should stay the way it is, just get a rename to something indicating what it does (i.e. 'Classification').

My initial goal for `La Junta Predictions.Rmd` was to make a nice overview of the data. It served that purpose well, but the names of the files are getting confusing. I have a better idea of the relevant questions to ask from this dataset, so new (very similar files) might be created in the future to find more pertinent answers.

The classification models helped me get a better grasp of the cattle categories, so now the most important questions should be asked. _How can we effectively predict the price?_

This file, and others in the Experimentation folder, are meant to dive deeper into the data and look for trends.




# Introduction

In this document, we will be working to estimate the price of cattle in the La Junta sale barn.

```{r setup-packages-data, include = FALSE}

knitr::opts_chunk$set(echo = FALSE,
                      results = "hide",
                      error = F,
                      warning = F,
                      message = F)


if(!require("pacman")) install.packages("pacman")
# General Packages
pacman::p_load(dplyr, ggplot2, readr, patchwork, clock)

# ARIMA Packages
pacman::p_load(forecast, tseries)



# Reading in the file and removing the URL column
lajunta <- read_csv("https://raw.githubusercontent.com/Ckrenzer/Winter-Livestock-Data/main/La%20Junta%20Market%20Reports.csv",
                    col_types = cols(Date = "D",
                                     Buyer = col_factor(),
                                     Quantity = col_double(),
                                     Type = col_factor(),
                                     Weight = col_double(),
                                     Price = col_double(),
                                     Reprod = col_factor())) %>% 
  dplyr::select(-URL)

```



To make this data time-series compatible, sales need to be grouped according to the date on which the sale took place. Therefore, the weekly values of the price are the median for that reproductive status (steers, heifers, etc.) at each sale. The median was chosen over the mean to reduce the chance that a few very expensive livestock can raise the average price higher than the rest of the cattle sold on the same date.

```{r prices over time, echo = FALSE, results = "show"}

# This code was taken from 'La Junta Predictions.Rmd'

# Price changes over time
q1 <- lajunta %>%  
  filter(Reprod %in% c("str", "hfr")) %>% 
  group_by(Date, Reprod) %>% 
  summarize(Price = median(Price)) %>% 
  ggplot() +
  geom_point(mapping = aes(x = Date, y = Price)) +
  geom_line(mapping = aes(x = Date, y = Price)) +
  facet_wrap(~Reprod) +
  ggtitle("Price Changes Over Time") +
  ylab("Median Price") +
  theme_dark()


q2 <-  lajunta %>%  
  filter(Reprod %in% c("bull", "cow")) %>% 
  group_by(Date, Reprod) %>% 
  summarize(Price = median(Price)) %>% 
  ggplot() +
  geom_point(mapping = aes(x = Date, y = Price)) +
  geom_line(mapping = aes(x = Date, y = Price)) +
  facet_wrap(~Reprod) +
  ylab("Median Price") +
  theme_dark()

# using patchwork's "/" operator
q1 / q2


# Removing variables we no longer need from the global enivronment
rm(q1, q2)

```



# Simple Moving Average

I am sure someone wrote a fine package with functions calculating the simple moving average, but let's just use the one I wrote below. We can use it to get a feel for where the market is going.


```{r simple moving average}

simple_moving_average <- function(df, reprod_status, variable_name, n){
  weekly_avg <- df %>% 
    filter(Reprod == reprod_status) %>%  
    group_by(Date) %>% 
    summarize("mean_price" = mean({{variable_name}}))
  
  avg <- numeric(nrow(weekly_avg) - n)
  
  #pre-allocating space in a vector
  last_date_in_period <- character(nrow(weekly_avg) - n)
  
  for(i in n:nrow(weekly_avg)){
    avg[(i-n)] <- mean(weekly_avg$mean_price[(i-(n-1)):i])
    last_date_in_period[i-n] <- as.character(weekly_avg$Date[i])
    
  }
  last_date_in_period <- as.Date(last_date_in_period)
  
  sma_results <- data.frame(Date = last_date_in_period, Avg_Price = avg)
  
  return(sma_results)
  
}#end of simple_moving_average()

```







```{r moving average plots, echo = FALSE, results = "show"}

# steers
steer_sma_plot <- simple_moving_average(df = lajunta, reprod_status = "str", variable_name = Price, n = 52) %>% 
  ggplot() +
  geom_line(mapping = aes(x = Date, y = Avg_Price), color = "orange", size = 1) +
  ggtitle("Steer") +
  xlab("Final Date in Period") +
  ylab("Average Price") +
  theme_minimal()


# heifers
heifer_sma_plot <- simple_moving_average(df = lajunta, reprod_status = "hfr", variable_name = Price, n = 52) %>% 
  ggplot() +
  geom_line(mapping = aes(x = Date, y = Avg_Price), color = "orange", size = 1) +
  ggtitle("Heifer") +
  xlab("Final Date in Period") +
  ylab("Average Price") +
  theme_minimal()


# cows
cow_sma_plot <- simple_moving_average(df = lajunta, reprod_status = "cow", variable_name = Price, n = 52) %>% 
  ggplot() +
  geom_line(mapping = aes(x = Date, y = Avg_Price), color = "orange", size = 1) +
  ggtitle("Cow") +
  xlab("Final Date in Period") +
  ylab("Average Price") +
  theme_minimal()


# bulls
bull_sma_plot <- simple_moving_average(df = lajunta, reprod_status = "bull", variable_name = Price, n = 52) %>% 
  ggplot() +
  geom_line(mapping = aes(x = Date, y = Avg_Price), color = "orange", size = 1) +
  ggtitle("Bull") +
  xlab("Final Date in Period") +
  ylab("Average Price") +
  theme_minimal()


# Plotting the graphs in a grid
steer_sma_plot + heifer_sma_plot + cow_sma_plot + bull_sma_plot + plot_annotation(title = "The Simple Moving Average for the Previous 52 Sales")

# Removing variables we no longer need from the global environment
rm(steer_sma_plot, heifer_sma_plot, cow_sma_plot, bull_sma_plot)

```




We can see the market is on an upward trajectory from lows of 2020. Whether theses gains will continue beyond the recovery point remains a question only time will tell. But, for now anyway, we see sales prices increasing. 


# ARIMA

Let's use an ARIMA model to predict the sales price of the different reproductive statuses of cattle. I'll let someone write the functions for me this time!

## Data Prep

The data prep follows these steps:

-   Store subsets of the data (steers, heifers, etc.) into their own data frames and calculate the median price at each sale. __(data prep)__

-   Make the price a time series column. __(data prep)__

-   Calculate moving averages for the data--eight weeks and 26 weeks (6 months) are used for this. __(data prep)__

-   Calculate a new column for a seasonally adjusted variable. __(data prep)__

-   Test for stationarity with the Augmented Dickey-Fuller test. __(differencing)__

-   Correct for non-stationarity via differencing: Use Autocorrelation function (ACF) plots to determine the order of differencing for multiplicative models and partial autocorrelation plots (PACF) to determine the order of differencing for additive models. __(differencing)__

-   Determine model parameters. __(differencing)__

-   Fit and evaluate the model. __(fitting)__

```{r data prep}

# STEP 1
# Storing the average sale price of each reproductive status into an object
avg_steer_prices <- filter(lajunta, Reprod == "str") %>% 
  group_by(Date) %>% 
  summarize("median_price" = median(Price))

avg_heifer_prices <- filter(lajunta, Reprod == "hfr") %>% 
  group_by(Date) %>% 
  summarize("median_price" = median(Price))

avg_cow_prices <- filter(lajunta, Reprod == "cow") %>% 
  group_by(Date) %>% 
  summarize("median_price" = median(Price))

avg_bull_prices <- filter(lajunta, Reprod == "bull") %>% 
  group_by(Date) %>% 
  summarize("median_price" = median(Price))




# STEP 2
# Making the price a time-series object with the stats package's ts()
# and checking for outliers with forecast's tsclean()
avg_steer_prices <- avg_steer_prices %>% 
  mutate("cleaned_price" = tsclean(ts(avg_steer_prices$median_price)))

avg_heifer_prices<- avg_heifer_prices %>% 
  mutate("cleaned_price" = tsclean(ts(avg_heifer_prices$median_price)))

avg_cow_prices <- avg_cow_prices %>% 
  mutate("cleaned_price" = tsclean(ts(avg_cow_prices$median_price)))

avg_bull_prices <- avg_bull_prices %>% 
  mutate("cleaned_price" = tsclean(ts(avg_bull_prices$median_price)))




# STEP 3
# Making columns containing moving averages
avg_steer_prices <- avg_steer_prices %>% 
  mutate("ma_2mo" = ma(avg_steer_prices$cleaned_price, order=8),
         "ma_6mo" = ma(avg_steer_prices$cleaned_price, order=26))

avg_heifer_prices <- avg_heifer_prices %>% 
  mutate("ma_2mo" = ma(avg_heifer_prices$cleaned_price, order=8),
         "ma_6mo" = ma(avg_heifer_prices$cleaned_price, order=26))

avg_cow_prices <- avg_cow_prices %>% 
  mutate("ma_2mo" = ma(avg_cow_prices$cleaned_price, order=8),
         "ma_6mo" = ma(avg_cow_prices$cleaned_price, order=26))

avg_bull_prices <- avg_bull_prices %>% 
  mutate("ma_2mo" = ma(avg_bull_prices$cleaned_price, order=8),
         "ma_6mo" = ma(avg_bull_prices$cleaned_price, order=26))




# STEP 4
# Creating a de-seasonalized column
# PARTS:
#   1. Calculate moving average (completed above)
#   2. Extract the seasonal, trend, and cycle components to the model
#         (Done with calls to stl()--but all missing values must be removed)
#         (Determine whether an additive or multiplicative model is more appropriate
#          --additive model is more appropriate for this data).
#   3. De-seasonalize the data with a call to seasadj()
#       It calculates the seasonal component of the series using smoothing, and adjusts
#       the original series by subtracting seasonality.
#           We use 26 as the frequency for the ts() call because we have 36 sales per period
avg_steer_prices <- avg_steer_prices %>% 
  mutate("seas_adj" = c(rep(NA, 26), seasadj(stl(ts(na.omit(avg_steer_prices$ma_6mo), frequency=26) , s.window="periodic"))))

avg_heifer_prices <- avg_heifer_prices %>% 
  mutate("seas_adj" = c(rep(NA, 26), seasadj(stl(ts(na.omit(avg_heifer_prices$ma_6mo), frequency=26) , s.window="periodic"))))

avg_cow_prices <- avg_cow_prices %>% 
  mutate("seas_adj" = c(rep(NA, 26), seasadj(stl(ts(na.omit(avg_cow_prices$ma_6mo), frequency=26) , s.window="periodic"))))

avg_bull_prices <- avg_bull_prices %>% 
  mutate("seas_adj" = c(rep(NA, 26), seasadj(stl(ts(na.omit(avg_bull_prices$ma_6mo), frequency=26) , s.window="periodic"))))

```


## Differencing

The next steps will be completed by reproductive status, since it makes the most sense to make decisions about the model one group at a time.

If the p-value from the ADF test is not significant, the data needs to be made stationary. To do this, we must find an appropriate order of differencing, which can be found visually with the Pacf() function (or Acf() if using a multiplicative model).

```{r steer differencing, echo = FALSE, results = "show"}

# STEP 5
# Augmented Dickey-Fuller test for stationary data
adf.test(ts(na.omit(avg_steer_prices$seas_adj), frequency=8))
cat("Fail to reject the null hypothesis--the data is non-stationary.")


# This plot helps to determine the correct order of differencing.
Pacf(ts(na.omit(avg_steer_prices$seas_adj)))
cat("The first two differences should be used.")




# PARAMETERS
steer_lags <- 1

steer_diff_deg <- 2

# The series displays a sharp autocorrelative cutoff,
# so one will be added to the moving average term, q
steer_ma_term <- 2





# Making a new column with containing the values after differencing.
avg_steer_prices <- avg_steer_prices %>% 
  mutate("seas_adj_diff" = c(rep(NA, steer_diff_deg), diff(avg_steer_prices$seas_adj, differences = steer_diff_deg)))


# The p-values on the Augmented Dickey-Fuller test are now significant--we took care of 
# non-stationary data.
adf.test(na.omit(avg_steer_prices$seas_adj_diff), alternative = "stationary")
cat("The p-values on the Augmented Dickey-Fuller test are now significant. We have stationary data!")

```



We now repeat the process for heifers:

```{r heifer differencing, echo = FALSE, results = "show"}

# STEP 5
# Augmented Dickey-Fuller test for stationary data
adf.test(ts(na.omit(avg_heifer_prices$seas_adj), frequency=8))
cat("Fail to reject the null hypothesis--the data is non-stationary.")


# This plot helps to determine the correct order of differencing.
Pacf(ts(na.omit(avg_heifer_prices$seas_adj)))
cat("The first two differences should be used.")




# PARAMETERS
heifer_lags <- 1

heifer_diff_deg <- 1

# The series displays a sharp autocorrelative cutoff,
# so one will be added to the moving average term, q
heifer_ma_term <- 2





# Making a new column with containing the values after differencing.
avg_heifer_prices <- avg_heifer_prices %>% 
  mutate("seas_adj_diff" = c(rep(NA, 1), diff(avg_heifer_prices$seas_adj, differences = 1)))


# The p-values on the Augmented Dickey-Fuller test are now significant--we took care of 
# non-stationary data.
adf.test(na.omit(avg_heifer_prices$seas_adj_diff), alternative = "stationary")
cat("The p-values on the Augmented Dickey-Fuller test are now significant. We have stationary data!")

```



We repeat the process again for cows:

```{r cow differencing, echo = FALSE, results = "show"}

# STEP 5
# Augmented Dickey-Fuller test for stationary data
adf.test(ts(na.omit(avg_cow_prices$seas_adj), frequency=8))
cat("Fail to reject the null hypothesis--the data is non-stationary.")


# This plot helps to determine the correct order of differencing.
Pacf(ts(na.omit(avg_cow_prices$seas_adj)))
cat("The first difference should be used.")




# PARAMETERS
cow_lags <- 1

cow_diff_deg <- 1

# The series displays a sharp autocorrelative cutoff,
# so one will be added to the moving average term, q
cow_ma_term <- 2





# Making a new column with containing the values after differencing.
avg_cow_prices <- avg_cow_prices %>% 
  mutate("seas_adj_diff" = c(rep(NA, 1), diff(avg_cow_prices$seas_adj, differences = 1)))


# The p-values on the Augmented Dickey-Fuller test are now significant--we took care of 
# non-stationary data.
adf.test(na.omit(avg_cow_prices$seas_adj_diff), alternative = "stationary")
cat("The p-values on the Augmented Dickey-Fuller test are now significant. We have stationary data!")

```


We repeat the process once more for bullss:

```{r bull differencing, echo = FALSE, results = "show"}

# STEP 5
# Augmented Dickey-Fuller test for stationary data
adf.test(ts(na.omit(avg_bull_prices$seas_adj), frequency=8))
cat("Fail to reject the null hypothesis--the data is non-stationary.")


# This plot helps to determine the correct order of differencing.
Pacf(ts(na.omit(avg_bull_prices$seas_adj)))
cat("The first difference should be used.")




# PARAMETERS
bull_lags <- 1

bull_diff_deg <- 1

# The series displays a sharp autocorrelative cutoff,
# so one will be added to the moving average term, q
bull_ma_term <- 2





# Making a new column with containing the values after differencing.
avg_bull_prices <- avg_bull_prices %>% 
  mutate("seas_adj_diff" = c(rep(NA, 1), diff(avg_bull_prices$seas_adj, differences = 1)))


# The p-values on the Augmented Dickey-Fuller test are now significant--we took care of 
# non-stationary data.
adf.test(na.omit(avg_bull_prices$seas_adj_diff), alternative = "stationary")
cat("The p-values on the Augmented Dickey-Fuller test are now significant. We have stationary data!")

```

### Date Vector

```{r date vector}

# STEP 0
# Making a date vector helpful for plotting in ggplot later
dates <- as.Date(character(0))

for(num_weeks in 1:26){
  
  dates[num_weeks] <- clock::add_weeks(avg_steer_prices$Date[avg_steer_prices$Date == max(avg_steer_prices$Date)], num_weeks)
  
}#end of for loop

```




## Model Fitting

With all data stationary, we can now determine the parameters for the model. The __parameters__ for ARIMA models are the following:

-   _p_: Specifies the number of __lags__ (previous terms) used in the model.

-   _d_: Specifies the __degree of differencing__ in the integreated component. Differencing involves subtracting its current and previous values _d_ times. This is used to maintain the stationarity assumption.

-   _q_: Specifies the __moving average component__, or the error of the model, as a combination of previous error terms. Determines the number of terms to include in the model.


We could have just let R do all the work for us and used auto.arima() to fit the model for us, but it never hurts to build models from the ground up--a good learning exercise! Plus, doing the work manually allows us to tune the model to our liking.


```{r steer model fitting}

# The steer model
steer_fit <- arima(avg_steer_prices$seas_adj, order = c(steer_lags, steer_diff_deg, steer_ma_term))

# The predictions for the model, six months out.
steer_predictions <- forecast(steer_fit, h = 26)

# Adding in the date column for the six month forecast
steer_predictions <- as_tibble(steer_predictions) %>% 
  mutate(Date = dates)


# The six month forecast
steer_forecast <- ggplot() +
  geom_line(data = avg_steer_prices, mapping = aes(x = Date, y = seas_adj), color = "orange", size = 1) +
  geom_ribbon(data = steer_predictions, mapping = aes(x = Date, ymin = `Lo 95`, ymax = `Hi 95`),
              fill = "red") +
  geom_ribbon(data = steer_predictions, mapping = aes(x = Date, ymin = `Lo 80`, ymax = `Hi 80`), fill = "lightblue") +
  geom_line(data = steer_predictions, mapping = aes(x = Date, y = `Point Forecast`), color = "blue", size = 1) +
  ggtitle("Seasonally Adjusted Six Month Forecast of Steer Prices in La Junta, CO") +
  xlab("Date") +
  ylab("Price") +
  theme_dark()

```



```{r heifer model fitting, echo = FALSE}

# The steer model
heifer_fit <- arima(avg_heifer_prices$seas_adj, order = c(heifer_lags, heifer_diff_deg, heifer_ma_term))

# The predictions for the model, six months out.
heifer_predictions <- forecast(heifer_fit, h = 26)

# Adding in the date column for the six month forecast
heifer_predictions <- as_tibble(heifer_predictions) %>% 
  mutate(Date = dates)


# The six month forecast
heifer_forecast <- ggplot() +
  geom_line(data = avg_heifer_prices, mapping = aes(x = Date, y = seas_adj), color = "orange", size = 1) +
  geom_ribbon(data = heifer_predictions, mapping = aes(x = Date, ymin = `Lo 95`, ymax = `Hi 95`),
              fill = "red") +
  geom_ribbon(data = heifer_predictions, mapping = aes(x = Date, ymin = `Lo 80`, ymax = `Hi 80`), fill = "lightblue") +
  geom_line(data = heifer_predictions, mapping = aes(x = Date, y = `Point Forecast`), color = "blue", size = 1) +
  ggtitle("Seasonally Adjusted Six Month Forecast of Heifer Prices in La Junta, CO") +
  xlab("Date") +
  ylab("Price") +
  theme_dark()

```



```{r cow model fitting, echo = FALSE}

# The steer model
cow_fit <- arima(avg_cow_prices$seas_adj, order = c(cow_lags, cow_diff_deg, cow_ma_term))

# The predictions for the model, six months out.
cow_predictions <- forecast(cow_fit, h = 26)

# Adding in the date column for the six month forecast
cow_predictions <- as_tibble(cow_predictions) %>% 
  mutate(Date = dates)


# The six month forecast
cow_forecast <- ggplot() +
  geom_line(data = avg_cow_prices, mapping = aes(x = Date, y = seas_adj), color = "orange", size = 1) +
  geom_ribbon(data = cow_predictions, mapping = aes(x = Date, ymin = `Lo 95`, ymax = `Hi 95`),
              fill = "red") +
  geom_ribbon(data = cow_predictions, mapping = aes(x = Date, ymin = `Lo 80`, ymax = `Hi 80`), fill = "lightblue") +
  geom_line(data = cow_predictions, mapping = aes(x = Date, y = `Point Forecast`), color = "blue", size = 1) +
  ggtitle("Seasonally Adjusted Six Month Forecast of Cow Prices in La Junta, CO") +
  xlab("Date") +
  ylab("Price") +
  theme_dark()

```



```{r bull model fitting, echo = FALSE}

# The steer model
bull_fit <- arima(avg_bull_prices$seas_adj, order = c(bull_lags, bull_diff_deg, bull_ma_term))

# The predictions for the model, six months out.
bull_predictions <- forecast(bull_fit, h = 26)

# Adding in the date column for the six month forecast
bull_predictions <- as_tibble(bull_predictions) %>% 
  mutate(Date = dates)


# The six month forecast
bull_forecast <- ggplot() +
  geom_line(data = avg_bull_prices, mapping = aes(x = Date, y = seas_adj), color = "orange", size = 1) +
  geom_ribbon(data = bull_predictions, mapping = aes(x = Date, ymin = `Lo 95`, ymax = `Hi 95`),
              fill = "red") +
  geom_ribbon(data = bull_predictions, mapping = aes(x = Date, ymin = `Lo 80`, ymax = `Hi 80`), fill = "lightblue") +
  geom_line(data = bull_predictions, mapping = aes(x = Date, y = `Point Forecast`), color = "blue", size = 1) +
  ggtitle("Seasonally Adjusted Six Month Forecast of Bull Prices in La Junta, CO") +
  xlab("Date") +
  ylab("Price") +
  theme_dark()

```


## ARIMA Results

The moment we've all been waiting for. Where do these models say the La Junta market is going?

```{r arima plots, results = "show"}

steer_forecast

heifer_forecast

cow_forecast

bull_forecast

```

